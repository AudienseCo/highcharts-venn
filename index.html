<html>

	<head>
	
		<style>
	
	#container{
		
		width:500px;
		height:450px;
		
	}
	


	</style>

	
	</head>
	
	
	
	<body>
	
	
	<div id="container"></div>
	
		<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	

	
	<script type="text/javascript" src="test/js/highcharts/highcharts.js"></script>
	
		<script type="text/javascript">
			
//GLOBAL VARIABLE///


//followers

followA=500000;
followB=250000;
followC=100000;


followAB=3000;
followAC=10000;
followBC=75000;
followABC=0;


//diagrama scale

 
 widthDiv=500;
 heightDiv=450;
 
 scale=null;	
//radios of circles

rA = null;
rB = null;
rC = null;

//intersections of circles

ab = null;
ac = null;
cb = null;

//positions of circles

cA={x: null, y: null};
cB={x: null, y: null};
cC={x: null, y: null};

// intersection points

ABinter=null;
ACinter=null;
BCinter=null;
ABCinter=null;


// svg size

var svgWidth=null;
var svgHeight=null;
			
//////FUNCTIONS /////



// size of svg and container

function sizeContainer(width, height){
	
	
	svgWidth=width;
	svgHeight=height;
	
	document.getElementById('container').style.width=width;
	document.getElementById('container').style.height=height;
		

	cA.x=(width*0.40);
	 cA.y=(height*0.60);
	
	circleSize=width/5; //our max size is 500px  of width

	return circleSize;
	
} //position and size of container. position fo diagram. return circle porcentage


//scale of circles		
function createScale(max){
	var maxArea = Math.pow(max,2)*Math.PI;
	return function scale(n){
		
		if(n>100)
			n=100;
					
    return Math.sqrt(((n*maxArea)/100)/Math.PI);
  } 
} 


//intersection of AC BC AND ABC

/*
function lineInterAC(ax1, ay1, ax2, ay2){
    
    var flag=0;
    var distancia=Math.sqrt(Math.pow(ax2-ax1,2)+Math.pow(ay2-ay1,2));

	if(distancia<rA){
	    flag=1;
	    
	}
	
    
	return flag;
}

*/

function lineInterAC(){
    
    
     var puntoInterAC={x:ACinter.x0, y:ACinter.y0}; //el punto que se encuentra en mitad de la interseccion
    var flag=0;
    var distancia=Math.sqrt(Math.pow(ACinter.x0-ACinter.x1,2)+Math.pow(ACinter.y0-ACinter.y1,2));
    var pendiente=(ACinter.y1-ACinter.y0)/(ACinter.x1-ACinter.x0);
    var intercepto=ACinter.y0-(pendiente*ACinter.x0); 
   
    mitad=(ACinter.x1-ACinter.x0)/2; //la mitad de la linea de intercepcion
   
   puntoInterAC.x=ACinter.x0+mitad;
   puntoInterAC.y=(pendiente)*(puntoInterAC.x)+intercepto;
   
    if(puntoInterAC.x>cC.x && puntoInterAC.y<cC.y){
	
	    flag=1;
	    
    }
	
    console.log(flag);
	return flag;

   

/*    
    renderer.circle(ACinter.x0, ACinter.y0, 2, 2).attr({
    fill: 'red',
 
    'stroke-width': 1
}).add(); 
    
    renderer.circle(ACinter.x0+mitad,  puntoInterAC.y, 2, 2).attr({
    fill: 'green',
 
    'stroke-width': 1
}).add();

renderer.circle(cC.x,  cC.y, 2, 2).attr({
    fill: 'black',
 
    'stroke-width': 1
}).add();

*/

    
}


function lineInterBC(){
    
    
    
         var puntoInterBC={x:BCinter.x0, y:BCinter.y0}; //el punto que se encuentra en mitad de la interseccion
    var flag=0;
    
    renderer.circle(BCinter.x0, BCinter.y0, 2, 2).attr({
    fill: 'red',
 
    'stroke-width': 1
}).add(); 
    
    
    
    var pendiente=(BCinter.y1-BCinter.y0)/(BCinter.x1-BCinter.x0);
    var intercepto=BCinter.y0-(pendiente*BCinter.x0); 
   
    mitad=(BCinter.x1-BCinter.x0)/2; //la mitad de la linea de intercepcion
   
   puntoInterBC.x=BCinter.x0+mitad;
   puntoInterBC.y=(pendiente)*(puntoInterBC.x)+intercepto;
   
    if(puntoInterBC.x<cC.x){
	
	    flag=1;
	    
    }
	
    
    console.log(flag);
	return flag;

   
    
    /*
    var puntoInterBC={x:BCinter.x0, y:BCinter.y0}; //el punto que se encuentra en mitad de la interseccion
    var flag=0;
    var distancia=Math.sqrt(Math.pow(BCinter.x0-BCinter.x1,2)+Math.pow(BCinter.y0-BCinter.y1,2));
    var pendiente=(BCinter.y1-BCinter.y0)/(BCinter.x1-BCinter.x0);
    var con=0;
    console.log("x 0 inter" + BCinter.x0);
     console.log("x 1 inter" + BCinter.x1);
     
     
    for(i=BCinter.x0; i<(distancia/2); i++){
	con++;
	
	puntoInterBC.x=puntoInterBC.x+con;
	puntoInterBC.y=puntoInterBC.y-pendiente;
    }
	if(puntoInterBC.y<cC.y){
	    flag=1;
	    
	}
	
    console.log(flag);
	return flag;
	
	
	*/
}

function interABC(){
    
    flag=true;
    
     var distancia=Math.sqrt(Math.pow(cC.x-ABinter.x0,2)+Math.pow(cC.y-ABinter.y0,2));
    
	console.log('distancia'+distancia);
    if(distancia>rC || followABC==0 ){
	
	flag=false;
    }
    
    console.log(flag);
    
    return flag;
    
}

//

//return intersectionCircle

function intersection(x0, y0, r0, x1, y1, r1) {
  var a, dx, dy, d, h, rx, ry;
  var x2, y2, i=0;

  /* dx and dy are the vertical and horizontal distances between
   * the circle centers.
   */
  dx = x1 - x0;
  dy = y1 - y0;

  /* Determine the straight-line distance between the centers. */
  d = Math.sqrt((dy*dy) + (dx*dx));
  while(i<0){ //TODO

    /* Check for solvability. */
    if (!( d > (r0 + r1) || d < Math.abs(r0-r1))) {
        /* no solution. circles do not intersect. */
        /* no solution. one circle is contained in the other */
        // return false;
        break;
    }
    d++;
    
    i++;
  }
  if(i===5) return false;

  /* 'point 2' is the point where the line through the circle
   * intersection points crosses the line between the circle
   * centers.  
   */

  /* Determine the distance from point 0 to point 2. */
  a = ((r0*r0) - (r1*r1) + (d*d)) / (2.0 * d) ;

  /* Determine the coordinates of point 2. */
  x2 = x0 + (dx * a/d);
  y2 = y0 + (dy * a/d);

  /* Determine the distance from point 2 to either of the
   * intersection points.
   */
  h = Math.sqrt((r0*r0) - (a*a));

  /* Now determine the offsets of the intersection points from
   * point 2.
   */
  rx = -dy * (h/d);
  ry = dx * (h/d);

  /* Determine the absolute intersection points. */
  var xi = x2 + rx;
  var xi_prime = x2 - rx;
  var yi = y2 + ry;
  var yi_prime = y2 - ry;

  return [xi, xi_prime, yi, yi_prime];
} 

///****GENERAL CODE******////


//create and set Scale//
 percentageSize=sizeContainer(widthDiv,  heightDiv); 

 scale = createScale(percentageSize);
 
 
rA = scale(followA/5000);
rB = scale(followB/5000);
rC = scale(followC/5000);

//intersections of circles

ab = scale(followAB/5000);
ac = scale(followAC/5000);
cb = scale(followBC/5000);

console.log(cb);
console.log(rC);
//setPositionOfCB

cB = {x: cA.x+rA+rB-2*ab, y: cA.y}; //we set cA in sizeContainer function


//setPosition Circle C if Circle C is not null


if(rC!=null){
	rAC = rA+rC-ac*2;
	rCB = rB+rC-cb*2;


	intsec = intersection(cA.x, cA.y, rAC, cB.x, cB.y, rCB);
	console.log("intsec"+intsec);
	
	if(isNaN(intsec[1])){
	    
	    intsec[3]=cA.y;
	    intsec[1]=cA.x+rAC;
	    
	}
	cC = {x: intsec[1], y: intsec[3]};

}
//INTERSECTION 
	
	
if(ab!=null){
		//INTERSECTION OF A CIRCLE AND B CIRCLE
		intsec=intersection(cA.x, cA.y, rA, cB.x, cB.y, rB);
		ABinter={x0: intsec[1], y0: intsec[3], x1: intsec[0], y1: intsec[2]};
}

if(ac!=null){
	//INTERSECTION OF A CIRCLE AND C CIRCLE
	intsec=intersection(cA.x, cA.y, rA, cC.x, cC.y, rC);
	ACinter={x0: intsec[1], y0: intsec[3], x1: intsec[0], y1: intsec[2]};
}

if(cb!=null){
	//INTERSECTION OF B CIRCLE AND C CIRCLE
	intsec=intersection(cB.x, cB.y, rB, cC.x, cC.y, rC);
	BCinter={x0: intsec[1], y0: intsec[3], x1: intsec[0], y1: intsec[2]};
}

if((ac!=null) && (cb>0 || cb!=null)){
	//INTERSECTION ABC
	ABCinter={x0:ABinter.x0, y0:ABinter.y0, x1:ACinter.x1, y1:ACinter.y1, x2:BCinter.x0, y2:BCinter.y0};
	
}



//***HIGHCHART DIAGRAMS ***////
var renderer = new Highcharts.Renderer(
    $('#container')[0],
    svgWidth, 
    svgHeight
);


renderer.circle(cA.x, cA.y, rA, rA).attr({
    fill: 'blue',
 
    'fill-opacity': 0.5,
    'stroke-width': 1
}).add();


renderer.circle(cB.x, cB.y, rB, rB).attr({
    fill: 'green',
    'fill-opacity': 0.5,
    'stroke-width': 1
}).add();


//intersection AB///
if(ab!=null){
	
	if(ABinter.x0>cB.x){
		eje=1;
	}else{
		eje=0;
	}
	
	renderer.path(['M', ABinter.x0, ABinter.y0, 'A', rB, rB ,0, eje, 0, ABinter.x1, ABinter.y1, 'M', ABinter.x0, ABinter.y0, 'A', rA, rA, 0, 0, 1, ABinter.x1, ABinter.y1]).attr({
	fill: 'red',
    'fill-opacity': 0.5,
    'stroke-width': 1,
	onclick:"alert('inter AB')"
	
}).add();
	
	
	Intersection1=true;
}


if(rC!=null){
	
	renderer.circle(cC.x, cC.y, rC, rC).attr({
    fill: 'orange',
    'fill-opacity': 0.5,
    'stroke-width': 1
}).add();
	
	
	if(ac!=null){
		//A C INTERSECTION
	//eje=lineInterAC(cA.x, cA.y, cC.x, cC.y);
	    eje=lineInterAC();   
		renderer.path(['M', ACinter.x0, ACinter.y0, 'A', rC, rC ,0, eje, 0, ACinter.x1, ACinter.y1, 'M', ACinter.x0, ACinter.y0, 'A', rA, rA, 0, 0, 1, ACinter.x1, ACinter.y1]).attr({
			fill: 'red',
			'fill-opacity': 0.5,
			'stroke-width': 1,
			onclick:"alert('inter AC')"
		
		}).add();
	
	
    }
	
	if(cb!=null){
		//B C INTERSECTION
		
	    eje=lineInterBC();
		renderer.path(['M', BCinter.x0, BCinter.y0, 'A', rC, rC ,0, eje, 0, BCinter.x1, BCinter.y1, 'M', BCinter.x0, BCinter.y0, 'A', rB, rB, 0, 0, 1, BCinter.x1, BCinter.y1]).attr({
			fill: 'red',
			'fill-opacity': 0.5,
			'stroke-width': 1,
			onclick:"alert('inter BC')"

		}).add();

	
		Intersection3=true;
		
	}
	

    var flag=interABC();
		
	if(flag==true){	
		renderer.path(['M', ABCinter.x0, ABCinter.y0, 'A', rA, rA ,0, 0, 1, ABCinter.x1, 	ABCinter.y1, 'M', 
               ABCinter.x1, ABCinter.y1, 'A', rC, rC, 0, 0, 1, ABCinter.x2, ABCinter.y2, 'M', 
               ABCinter.x2, ABCinter.y2, 'A', rB, rB, 0, 0, 1, ABCinter.x0, ABCinter.y0,
               'M', ABCinter.x0, ABCinter.y0, 'L', ABCinter.x1, ABCinter.y1, 'L', 
                ABCinter.x2, ABCinter.y2, 'z']).attr({
		    fill: 'blue',
		    'fill-opacity': 0.5,
		    'stroke-width': 1,
		    onclick:"alert('inter ABC')"

		}).add();
		
	}		
		
	
		
	
	
	} //draw c circle
	
	
/*
 renderer.circle(cA.x, cA.y, rAC, rAC).attr({
     fill: 'transparent',
     stroke: 'orange',
     'stroke-width': 1
 }).add();

 renderer.circle(cB.x, cB.y, rCB, rCB).attr({
     fill: 'transparent',
     stroke: 'orange',
     'stroke-width': 1
 }).add();

*/
</script>
	
	
	</body>






</html>
